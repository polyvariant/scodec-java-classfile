package org.polyvariant.classfile.codecs

import scodec.Codec
import org.polyvariant.classfile._
import scodec.Err

object InstructionCodecs {
  import scodec.bits._
  import scodec.codecs._

  import ClassFileCodecs._

  val arrayType: Codec[ArrayType] = mappedEnum(
    u1, // todo: not sure about this exactly, but it seems to work
    ArrayType.T_BOOLEAN -> 4,
    ArrayType.T_CHAR -> 5,
    ArrayType.T_FLOAT -> 6,
    ArrayType.T_DOUBLE -> 7,
    ArrayType.T_BYTE -> 8,
    ArrayType.T_SHORT -> 9,
    ArrayType.T_INT -> 10,
    ArrayType.T_LONG -> 11,
  )

  val instruction: Codec[Instruction] = {
    import Instruction._
    val localIndex = ("local variable array index" | u1).as[LocalVariableIndex]

    val offset = ("offset" | u2).as[Offset]
    val offsetWide = ("offset" | u4).as[OffsetWide]

    discriminated[Instruction]
      .by(u1)
      .typecase(0x32, localIndex.as[dload])
      .typecase(0x53, provide(aastore))
      .typecase(0x01, provide(aconst_null))
      .typecase(0x19, localIndex.as[aload])
      .typecase(0x2a, provide(aload_0))
      .typecase(0x2b, provide(aload_1))
      .typecase(0x2c, provide(aload_2))
      .typecase(0x2d, provide(aload_3))
      .typecase(0xbd, constantPoolIndex.as[anewarray])
      .typecase(0xb0, provide(areturn))
      .typecase(0xbe, provide(arraylength))
      .typecase(0x3a, localIndex.as[astore])
      .typecase(0x4b, provide(astore_0))
      .typecase(0x4c, provide(astore_1))
      .typecase(0x4d, provide(astore_2))
      .typecase(0x4e, provide(astore_3))
      .typecase(0xbf, provide(athrow))
      .typecase(0x33, provide(baload))
      .typecase(0x54, provide(bastore))
      .typecase(0x10, byte.as[bipush])
      .typecase(0x34, provide(caload))
      .typecase(0x55, provide(castore))
      .typecase(0xc0, constantPoolIndex.as[checkcast])
      .typecase(0x90, provide(d2f))
      .typecase(0x8e, provide(d2i))
      .typecase(0x8f, provide(d2l))
      .typecase(0x63, provide(dadd))
      .typecase(0x31, provide(daload))
      .typecase(0x52, provide(dastore))
      .typecase(0x98, provide(dcmpg))
      .typecase(0x97, provide(dcmpl))
      .typecase(0x0e, provide(dconst_0))
      .typecase(0x0f, provide(dconst_1))
      .typecase(0x6f, provide(ddiv))
      .typecase(0x18, localIndex.as[dload])
      .typecase(0x26, provide(dload_0))
      .typecase(0x27, provide(dload_1))
      .typecase(0x28, provide(dload_2))
      .typecase(0x29, provide(dload_3))
      .typecase(0x6b, provide(dmul))
      .typecase(0x77, provide(dneg))
      .typecase(0x73, provide(drem))
      .typecase(0xaf, provide(dreturn))
      .typecase(0x39, localIndex.as[dstore])
      .typecase(0x47, provide(dstore_0))
      .typecase(0x48, provide(dstore_1))
      .typecase(0x49, provide(dstore_2))
      .typecase(0x4a, provide(dstore_3))
      .typecase(0x67, provide(dsub))
      .typecase(0x59, provide(dup))
      .typecase(0x5a, provide(dup_x1))
      .typecase(0x5b, provide(dup_x2))
      .typecase(0x5c, provide(dup2))
      .typecase(0x5d, provide(dup2_x1))
      .typecase(0x5e, provide(dup2_x2))
      .typecase(0x8d, provide(f2d))
      .typecase(0x8b, provide(f2i))
      .typecase(0x8c, provide(f2l))
      .typecase(0x62, provide(fadd))
      .typecase(0x30, provide(faload))
      .typecase(0x51, provide(fastore))
      .typecase(0x96, provide(fcmpg))
      .typecase(0x95, provide(fcmpl))
      .typecase(0x0b, provide(fconst_0))
      .typecase(0x0c, provide(fconst_1))
      .typecase(0x0d, provide(fconst_2))
      .typecase(0x6e, provide(fdiv))
      .typecase(0x17, localIndex.as[fload])
      .typecase(0x22, provide(fload_0))
      .typecase(0x23, provide(fload_1))
      .typecase(0x24, provide(fload_2))
      .typecase(0x25, provide(fload_3))
      .typecase(0x6a, provide(fmul))
      .typecase(0x76, provide(fneg))
      .typecase(0x72, provide(frem))
      .typecase(0xae, provide(freturn))
      .typecase(0x38, localIndex.as[fstore])
      .typecase(0x43, provide(fstore_0))
      .typecase(0x44, provide(fstore_1))
      .typecase(0x45, provide(fstore_2))
      .typecase(0x46, provide(fstore_3))
      .typecase(0x66, provide(fsub))
      .typecase(0xb4, constantPoolIndex.as[getfield])
      .typecase(0xb2, constantPoolIndex.as[getstatic])
      .typecase(0xa7, offset.as[goto])
      .typecase(0xc8, offsetWide.as[goto_w])
      .typecase(0x91, provide(i2b))
      .typecase(0x92, provide(i2c))
      .typecase(0x87, provide(i2d))
      .typecase(0x86, provide(i2f))
      .typecase(0x85, provide(i2l))
      .typecase(0x93, provide(i2s))
      .typecase(0x60, provide(iadd))
      .typecase(0x2e, provide(iaload))
      .typecase(0x7e, provide(iand))
      .typecase(0x4f, provide(iastore))
      .typecase(0x02, provide(iconst_m1))
      .typecase(0x03, provide(iconst_0))
      .typecase(0x04, provide(iconst_1))
      .typecase(0x05, provide(iconst_2))
      .typecase(0x06, provide(iconst_3))
      .typecase(0x07, provide(iconst_4))
      .typecase(0x08, provide(iconst_5))
      .typecase(0x6c, provide(idiv))
      .typecase(0xa5, offset.as[if_acmpeq])
      .typecase(0xa6, offset.as[if_acmpne])
      .typecase(0x9f, offset.as[if_icmpeq])
      .typecase(0xa0, offset.as[if_icmpne])
      .typecase(0xa1, offset.as[if_icmplt])
      .typecase(0xa2, offset.as[if_icmpge])
      .typecase(0xa3, offset.as[if_icmpgt])
      .typecase(0xa4, offset.as[if_icmple])
      .typecase(0x99, offset.as[ifeq])
      .typecase(0x9a, offset.as[ifne])
      .typecase(0x9b, offset.as[iflt])
      .typecase(0x9c, offset.as[ifge])
      .typecase(0x9d, offset.as[ifgt])
      .typecase(0x9e, offset.as[ifle])
      .typecase(0xc7, offset.as[ifnonnull])
      .typecase(0xc6, offset.as[ifnull])
      .typecase(0x84, (localIndex :: ("const" | byte)).as[iinc])
      .typecase(0x15, localIndex.as[iload])
      .typecase(0x1a, provide(iload_0))
      .typecase(0x1b, provide(iload_1))
      .typecase(0x1c, provide(iload_2))
      .typecase(0x1d, provide(iload_3))
      .typecase(0xfe, provide(imul))
      .typecase(0x74, provide(ineg))
      .typecase(0xc1, constantPoolIndex.as[instanceof])
      .typecase(0xba, (constantPoolIndex :: constant(hex"0000")).dropUnits.as[invokedynamic])
      .typecase(
        0xb9,
        (constantPoolIndex :: ("count" | u1) :: constant(hex"0")).dropUnits.as[invokeinterface],
      )
      .typecase(0xb7, constantPoolIndex.as[invokespecial])
      .typecase(0xb8, constantPoolIndex.as[invokestatic])
      .typecase(0xb6, constantPoolIndex.as[invokevirtual])
      .typecase(0x80, provide(ior))
      .typecase(0x70, provide(irem))
      .typecase(0xac, provide(ireturn))
      .typecase(0x78, provide(ishl))
      .typecase(0x7a, provide(ishr))
      .typecase(0x36, localIndex.as[istore])
      .typecase(0x3b, provide(istore_0))
      .typecase(0x3c, provide(istore_1))
      .typecase(0x3d, provide(istore_2))
      .typecase(0x3e, provide(istore_3))
      .typecase(0x64, provide(isub))
      .typecase(0x7c, provide(iushr))
      .typecase(0x82, provide(ixor))
      .typecase(0xa8, offset.as[jsr])
      .typecase(0xc9, offsetWide.as[jsr_w])
      .typecase(0x8a, provide(l2d))
      .typecase(0x89, provide(l2f))
      .typecase(0x88, provide(l2i))
      .typecase(0x61, provide(ladd))
      .typecase(0x2f, provide(laload))
      .typecase(0x7f, provide(land))
      .typecase(0x50, provide(lastore))
      .typecase(0x94, provide(lcmp))
      .typecase(0x09, provide(lconst_0))
      .typecase(0x0a, provide(lconst_1))
      .typecase(0x12, constantPoolIndex.as[ldc])
      .typecase(0x13, constantPoolIndex.as[ldc_w])
      .typecase(0x14, constantPoolIndex.as[ldc2_w])
      .typecase(0x6d, provide(ldiv))
      .typecase(0x16, localIndex.as[lload])
      .typecase(0x1e, provide(lload_0))
      .typecase(0x1f, provide(lload_1))
      .typecase(0x20, provide(lload_2))
      .typecase(0x21, provide(lload_3))
      .typecase(0x69, provide(lmul))
      .typecase(0x75, provide(lneg))
      .typecase(0xab, fail(Err("lookupswitch not supported")))
      .typecase(0x81, provide(lor))
      .typecase(0x71, provide(lrem))
      .typecase(0xad, provide(lreturn))
      .typecase(0x79, provide(lshl))
      .typecase(0x7b, provide(lshr))
      .typecase(0x37, localIndex.as[lstore])
      .typecase(0x3f, provide(lstore_0))
      .typecase(0x40, provide(lstore_1))
      .typecase(0x41, provide(lstore_2))
      .typecase(0x42, provide(lstore_3))
      .typecase(0x65, provide(lsub))
      .typecase(0x7d, provide(lushr))
      .typecase(0x83, provide(lxor))
      .typecase(0xc2, provide(monitorenter))
      .typecase(0xc3, provide(monitorexit))
      .typecase(0xc5, (constantPoolIndex :: u1).as[multianewarray])
      .typecase(0xbb, constantPoolIndex.as[_new])
      .typecase(0xbc, arrayType.as[newarray])
      .typecase(0x00, provide(nop))
      .typecase(0x57, provide(pop))
      .typecase(0x58, provide(pop2))
      .typecase(0xb5, constantPoolIndex.as[putfield])
      .typecase(0xb3, constantPoolIndex.as[putstatic])
      .typecase(0xa9, localIndex.as[ret])
      .typecase(0xb1, provide(_return))
      .typecase(0x35, provide(saload))
      .typecase(0x56, provide(sastore))
      .typecase(0x11, u2.as[sipush])
      .typecase(0x5f, provide(swap))
      .typecase(0xaa, fail(Err("tableswitch not supported")))
      .typecase(0xc4, fail(Err("wide not supported")))
  }

}
